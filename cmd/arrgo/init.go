package main

import (
	"bufio"
	"flag"
	"fmt"
	"os"
	"strings"
	"text/template"
)

const configTemplate = `# arrgo configuration
# Generated by arrgo init

[server]
host = "0.0.0.0"
port = 8484
log_level = "info"

[database]
path = "./data/arrgo.db"

[libraries.movies]
root = "{{.MoviesPath}}"
naming = "{title} ({year})/{title} ({year}) [{quality}].{ext}"

[libraries.series]
root = "{{.SeriesPath}}"
naming = "{title}/Season {season:02d}/{title} - S{season:02d}E{episode:02d} [{quality}].{ext}"

[quality]
default = "hd"

[quality.profiles.hd]
accept = ["1080p bluray", "1080p webdl", "1080p hdtv", "720p bluray", "720p webdl"]

[quality.profiles.uhd]
accept = ["2160p bluray", "2160p webdl", "1080p bluray", "1080p webdl"]

[quality.profiles.any]
accept = ["2160p", "1080p", "720p", "480p"]

[indexers.{{.IndexerName}}]
url = "{{.IndexerURL}}"
api_key = "{{.IndexerAPIKey}}"

[downloaders.sabnzbd]
url = "{{.SABnzbdURL}}"
api_key = "{{.SABnzbdAPIKey}}"
category = "{{.SABnzbdCategory}}"

[notifications.plex]
url = "http://localhost:32400"
token = ""
libraries = ["Movies", "TV Shows"]

[ai]
enabled = false
provider = "ollama"

[ai.ollama]
url = "http://localhost:11434"
model = "llama3.1:8b"
`

type initConfig struct {
	IndexerName     string
	IndexerURL      string
	IndexerAPIKey   string
	SABnzbdURL      string
	SABnzbdAPIKey   string
	SABnzbdCategory string
	MoviesPath      string
	SeriesPath      string
}

func runInit(args []string) {
	fs := flag.NewFlagSet("init", flag.ExitOnError)
	force := fs.Bool("force", false, "Overwrite existing config.toml")
	_ = fs.Parse(args)

	configPath := "config.toml"

	// Check if config exists
	if _, err := os.Stat(configPath); err == nil && !*force {
		fmt.Fprintf(os.Stderr, "config.toml already exists. Use --force to overwrite.\n")
		os.Exit(1)
	}

	fmt.Println("arrgo setup wizard")
	fmt.Println()

	cfg := gatherConfig()

	if err := writeConfig(cfg, configPath); err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		os.Exit(1)
	}

	fmt.Println()
	fmt.Println("Config written to config.toml")
	fmt.Println("Run 'arrgod' to start the server.")
}

func writeConfig(cfg initConfig, path string) error {
	tmpl, err := template.New("config").Parse(configTemplate)
	if err != nil {
		return fmt.Errorf("parse template: %w", err)
	}

	f, err := os.Create(path)
	if err != nil {
		return fmt.Errorf("create file: %w", err)
	}
	defer func() { _ = f.Close() }()

	if err := tmpl.Execute(f, cfg); err != nil {
		return fmt.Errorf("write config: %w", err)
	}

	return nil
}

func gatherConfig() initConfig {
	var cfg initConfig
	reader := bufio.NewReader(os.Stdin)

	cfg.IndexerName = promptWithDefault(reader, "Indexer name", "nzbgeek")
	cfg.IndexerURL = promptWithDefault(reader, "Indexer URL", "https://api.nzbgeek.info")
	cfg.IndexerAPIKey = promptRequired(reader, "Indexer API Key")
	fmt.Println()

	cfg.SABnzbdURL = promptWithDefault(reader, "SABnzbd URL", "http://localhost:8085")
	cfg.SABnzbdAPIKey = promptRequired(reader, "SABnzbd API Key")
	cfg.SABnzbdCategory = promptWithDefault(reader, "SABnzbd Category", "arrgo")
	fmt.Println()

	cfg.MoviesPath = promptWithDefault(reader, "Movies path", "/movies")
	cfg.SeriesPath = promptWithDefault(reader, "Series path", "/tv")

	return cfg
}

// promptWithDefault shows a prompt with default value in brackets.
// Returns the user's input, or the default if input is empty.
func promptWithDefault(reader *bufio.Reader, label, defaultVal string) string {
	if defaultVal != "" {
		fmt.Printf("%s [%s]: ", label, defaultVal)
	} else {
		fmt.Printf("%s: ", label)
	}
	input, _ := reader.ReadString('\n')
	input = strings.TrimSpace(input)
	if input == "" {
		return defaultVal
	}
	return input
}

// promptRequired prompts until a non-empty value is provided.
func promptRequired(reader *bufio.Reader, label string) string {
	for {
		fmt.Printf("%s: ", label)
		input, _ := reader.ReadString('\n')
		input = strings.TrimSpace(input)
		if input != "" {
			return input
		}
		fmt.Println("  Value required")
	}
}
